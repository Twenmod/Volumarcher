#include "pch.h"
#include "../MiniEngine/Core/GameCore.h"
#include "../MiniEngine/Core/GraphicsCore.h"
#include "../MiniEngine/Core/SystemTime.h"
#include "../MiniEngine/Core/TextRenderer.h"
#include "GameInput.h"
#include "PostEffects.h"
#include "UploadBuffer.h"
#include "../MiniEngine/Core/CommandContext.h"
#include "../MiniEngine/Core/RootSignature.h"
#include "../MiniEngine/Core/PipelineState.h"
#include "../MiniEngine/Core/BufferManager.h"

#include "Volumarcher.h"

using namespace GameCore;
using namespace Graphics;

class RendererApplication : public GameCore::IGameApp
{
public:
	RendererApplication()
	{
	}

	void Startup(void) override;

	void Cleanup(void) override;

	void Update(float deltaT) override;

	void InitRasterizor();
	void RenderRasterizerPass();

	void RenderScene(void) override;

private:
	std::unique_ptr<Volumarcher::VolumetricContext> m_volumetricContext;
	glm::vec3 m_camPos{0.f};
	glm::quat m_camRot{glm::identity<glm::quat>()};
	float m_camYaw{0.f};
	float m_camPitch{0.f};
	const float m_cameraSpeed{2.f};
	const float m_cameraRotSpeed{0.7f};

	//Cube/Rasterizor stuff
	StructuredBuffer vertexBuffer;
	StructuredBuffer indexBuffer;

	RootSignature g_RootSig;
	GraphicsPSO g_CubePSO;
};

#pragma region Cube

//Cube code generated by ChatGPT
struct Vertex
{
	float position[3];
};

static const Vertex cubeVertices[] =
{
	// A very plain cube (positions)
	{{-1, -1, -1}},
	{{1, -1, -1}},
	{{1, 1, -1}},
	{{-1, 1, -1}},

	{{-1, -1, 1}},
	{{1, -1, 1}},
	{{1, 1, 1}},
	{{-1, 1, 1}}
};

// Index buffer (12 triangles)
static const uint16_t cubeIndices[] =
{
	0, 1, 2, 0, 2, 3,
	4, 5, 6, 4, 6, 7,
	0, 4, 7, 0, 7, 3,
	1, 5, 6, 1, 6, 2,
	3, 2, 6, 3, 6, 7,
	0, 1, 5, 0, 5, 4
};

struct MatrixBuffer
{
	glm::mat4 MVP;
};

#include "CompiledShaders/PixelShader.h"
#include "CompiledShaders/VertexShader.h"

void RendererApplication::InitRasterizor()
{
	g_RootSig.Reset(1, 0);
	g_RootSig[0].InitAsConstants(0, sizeof(MatrixBuffer) / sizeof(float)); // Camera mat
	g_RootSig.Finalize(L"CubeRootSig", D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT);

	D3D12_INPUT_ELEMENT_DESC layout[] =
	{
		{"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0},
	};

	g_CubePSO.SetRootSignature(g_RootSig);
	g_CubePSO.SetInputLayout(_countof(layout), layout);
	g_CubePSO.SetRasterizerState({
		D3D12_FILL_MODE_SOLID, D3D12_CULL_MODE_NONE, true, 0, 0, 0, true, false, false, 0,
		D3D12_CONSERVATIVE_RASTERIZATION_MODE_ON
	});
	D3D12_DEPTH_STENCIL_DESC depthStencilDesc;
	depthStencilDesc.DepthEnable = true;
	depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_GREATER_EQUAL;
	depthStencilDesc.StencilEnable = false;
	depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
	D3D12_DEPTH_STENCILOP_DESC stencilDesc{};
	depthStencilDesc.BackFace = stencilDesc;
	depthStencilDesc.FrontFace = stencilDesc;
	g_CubePSO.SetDepthStencilState(depthStencilDesc);
	D3D12_BLEND_DESC blendState;
	blendState.IndependentBlendEnable = false;
	blendState.RenderTarget[0].BlendEnable = false;
	blendState.RenderTarget[0].RenderTargetWriteMask = D3D10_COLOR_WRITE_ENABLE_ALL;
	g_CubePSO.SetBlendState(blendState);
	g_CubePSO.SetPrimitiveTopologyType(D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE);
	g_CubePSO.SetRenderTargetFormat(DXGI_FORMAT_R11G11B10_FLOAT, DXGI_FORMAT_D32_FLOAT);
	g_CubePSO.SetVertexShader(g_pVertexShader, sizeof(g_pVertexShader));
	g_CubePSO.SetPixelShader(g_pPixelShader, sizeof(g_pPixelShader));


	g_CubePSO.Finalize();

	vertexBuffer.Create(L"Cube vertices", _countof(cubeVertices), sizeof(cubeVertices[0]), &cubeVertices);
	indexBuffer.Create(L"Cube Indices", _countof(cubeIndices), sizeof(cubeIndices[0]), &cubeIndices);
}

#pragma endregion


CREATE_APPLICATION(RendererApplication)

void RendererApplication::Startup(void)
{
	Utility::Printf("Starting Volumarcher demo\n");

	InitRasterizor();

	Utility::Printf("Creating Volumetric Context\n");
	CpuTimer startupTimer;
	startupTimer.Start();
	Volume volumes[VOLUME_AMOUNT] = {{float3(0, 0, 2), 4.f, 5.f}};
	m_volumetricContext = std::make_unique<Volumarcher::VolumetricContext>(volumes);
	PostEffects::BloomEnable = false;
	PostEffects::EnableHDR = false;
	PostEffects::EnableAdaptation = false;
	startupTimer.Stop();

	Utility::Printf("VolumetricContext Startup Time: %fs\n", startupTimer.GetTime());
}

void RendererApplication::Cleanup(void)
{
	// Free up resources in an orderly fashion
}

void RendererApplication::Update(const float _deltaTime)
{
	ScopedTimer _prof(L"Update State");


	//Rotation
	m_camYaw -= GameInput::GetAnalogInput(GameInput::kAnalogMouseX) * m_cameraRotSpeed;
	m_camPitch -= GameInput::GetAnalogInput(GameInput::kAnalogMouseY) * m_cameraRotSpeed;
	m_camPitch = glm::clamp(m_camPitch, -89.99f, 89.99f);
	m_camRot = glm::angleAxis(m_camYaw, glm::vec3(0, 1, 0)) * glm::angleAxis(m_camPitch, glm::vec3(1, 0, 0));

	//Movement
	glm::vec3 input{0.f};
	if (GameInput::IsPressed(GameInput::kKey_a)) input.x += 1;
	if (GameInput::IsPressed(GameInput::kKey_d)) input.x -= 1;
	if (GameInput::IsPressed(GameInput::kKey_w)) input.z += 1;
	if (GameInput::IsPressed(GameInput::kKey_s)) input.z -= 1;
	if (GameInput::IsPressed(GameInput::kKey_space)) input.y += 1;
	if (GameInput::IsPressed(GameInput::kKey_c)) input.y -= 1;
	if (glm::dot(input, input) > 0) input = normalize(input);
	m_camPos += (m_camRot * input) * m_cameraSpeed * _deltaTime;
}


void RendererApplication::RenderRasterizerPass()
{
	GraphicsContext& graphicsContext = GraphicsContext::Begin(L"Graphics Pass");
	graphicsContext.TransitionResource(g_SceneColorBuffer, D3D12_RESOURCE_STATE_RENDER_TARGET, true);
	graphicsContext.TransitionResource(g_SceneDepthBuffer,
	                                   D3D12_RESOURCE_STATE_DEPTH_WRITE, true);
	graphicsContext.ClearColor(g_SceneColorBuffer);
	graphicsContext.ClearDepth(g_SceneDepthBuffer);
	graphicsContext.SetRenderTarget(g_SceneColorBuffer.GetRTV(), g_SceneDepthBuffer.GetDSV());
	graphicsContext.SetViewportAndScissor(0, 0, g_SceneColorBuffer.GetWidth(), g_SceneColorBuffer.GetHeight());
	graphicsContext.SetRootSignature(g_RootSig);
	graphicsContext.SetPipelineState(g_CubePSO);

	graphicsContext.SetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

	D3D12_VERTEX_BUFFER_VIEW vbv;
	vbv.BufferLocation = vertexBuffer.GetGpuVirtualAddress();
	vbv.SizeInBytes = vertexBuffer.GetBufferSize();
	vbv.StrideInBytes = sizeof(Vertex);

	D3D12_INDEX_BUFFER_VIEW ibv;
	ibv.BufferLocation = indexBuffer.GetGpuVirtualAddress();
	ibv.SizeInBytes = indexBuffer.GetBufferSize();
	ibv.Format = DXGI_FORMAT_R16_UINT;

	graphicsContext.SetVertexBuffer(0, vbv);
	graphicsContext.SetIndexBuffer(ibv);

	glm::vec3 camDir = m_camRot * glm::vec3(0, 0, 1);
	glm::mat4 view = glm::lookAt(m_camPos, camDir, glm::vec3(0, 1, 0));
	static const glm::mat4 projection = glm::perspective(glm::radians(70.f), (16.f / 9.f), 0.01f, 50.f);

	MatrixBuffer constants{projection * view};
	graphicsContext.SetConstantArray(0, sizeof(MatrixBuffer) / sizeof(uint32_t), &constants);

	graphicsContext.DrawIndexed(_countof(cubeIndices));


	graphicsContext.Finish();
}



void RendererApplication::RenderScene(void)
{
	RenderRasterizerPass();

	//m_volumetricContext->Render(g_SceneColorBuffer, m_camPos, m_camRot);
}
